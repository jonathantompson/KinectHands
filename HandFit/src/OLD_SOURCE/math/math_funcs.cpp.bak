// File:		math_types.cpp
// Author:		Jonathan Tompson
// e-mail:		jjt2119@columbia.edu or jonathantompson@gmail.com

// Various math types (not commonly used) and some utility functions

#include "utils_and_misc_classes\math\math_funcs.h"
#include "utils_and_misc_classes\math\double3x3.h"
#include "utils_and_misc_classes\math\double4x4.h"
#include "utils_and_misc_classes\math\quaternion.h"
#include "utils_and_misc_classes\math\plane.h"
#include <math.h>
#include "dxInclude.h"
#include "utils_and_misc_classes\new_redefine.h" // MUST COME LAST

#define PI 3.14159264f
#define DEG2RAD (PI / 180.0)
#define RAD2DEG (180.0 / PI)
#define SQRT_OF_2 (1.4142135f)
#define OFFSET(Class,Member)  (((char*) (&(((Class*)NULL)-> Member )))- ((char*)NULL))

double   sqr(double a) {return a*a;}

double Round(double a,double precision)
{
	return floor(0.5+a/precision)*precision;
}


double Interpolate(const double &f0,const double &f1,double alpha)
{
	return f0*(1-alpha) + f1*alpha;
}

int     argmin(double a[],int n)
{
	int r=0;
	for(int i=1;i<n;i++) 
	{
		if(a[i]<a[r]) 
		{
			r = i;
		}
	}
	return r;
}

//--------- utility functions -------------

//        RotationArc()
// Given two vectors v0 and v1 this function
// returns quaternion q where q*v0==v1.
// Routine taken from game programming gems.
quaternion RotationArc(double3 v0,double3 v1){
	static quaternion q;
	v0 = normalize(v0);  // Comment these two lines out if you know its not needed.
	v1 = normalize(v1);  // If vector is already unit length then why do it again?
	double3  c = cross(v0,v1);
	double   d = dot(v0,v1);
	if(d<=-1.0) { return quaternion(1,0,0,0);} // 180 about x axis
	double   s = sqrt((1+d)*2);
	q.x = c.x / s;
	q.y = c.y / s;
	q.z = c.z / s;
	q.w = s /2.0;
	return q;
}


double4x4 MatrixFromQuatVec(const quaternion &q, const double3 &v) 
{
	// builds a 4x4 transformation matrix based on orientation q and translation v 
	double qx2 = q.x*q.x;
	double qy2 = q.y*q.y;
	double qz2 = q.z*q.z;

	double qxqy = q.x*q.y;
	double qxqz = q.x*q.z;
	double qxqw = q.x*q.w;
	double qyqz = q.y*q.z;
	double qyqw = q.y*q.w;
	double qzqw = q.z*q.w;

	return double4x4(
		1-2*(qy2+qz2),  
		2*(qxqy+qzqw),
		2*(qxqz-qyqw),  
		0            ,  
		2*(qxqy-qzqw),  
		1-2*(qx2+qz2),
		2*(qyqz+qxqw),  
		0            ,  
		2*(qxqz+qyqw),  
		2*(qyqz-qxqw),  
		1-2*(qx2+qy2),  
		0    , 
		v.x ,
		v.y ,
		v.z ,
		1.0 );
}


double3 PlaneLineIntersection(const plane &plane, const double3 &p0, const double3 &p1)
{
	// returns the point where the line p0-p1 intersects the plane n&d
	static double3 dif;
	dif = p1-p0;
	double dn= dot(plane.normal,dif);
	double t = -(plane.dist+dot(plane.normal,p0) )/dn;
	return p0 + (dif*t);
}

double3 PlaneProject(const plane &plane, const double3 &point)
{
	return point - plane.normal * (dot(point,plane.normal)+plane.dist);
}

double3 LineProject(const double3 &p0, const double3 &p1, const double3 &a)
{
	double3 w;
	w = p1-p0;
	double t= dot(w,(a-p0)) / (sqr(w.x)+sqr(w.y)+sqr(w.z));
	return p0+ w*t;
}


double LineProjectTime(const double3 &p0, const double3 &p1, const double3 &a)
{
	double3 w;
	w = p1-p0;
	double t= dot(w,(a-p0)) / (sqr(w.x)+sqr(w.y)+sqr(w.z));
	return t;
}



double3 TriNormal(const double3 &v0, const double3 &v1, const double3 &v2)
{
	// return the normal of the triangle
	// inscribed by v0, v1, and v2
	double3 cp=cross(v1-v0,v2-v1);
	double m=magnitude(cp);
	if(m==0) return double3(1,0,0);
	return cp*(1.0/m);
}



int BoxInside(const double3 &p, const double3 &bmin, const double3 &bmax) 
{
	return (p.x >= bmin.x && p.x <=bmax.x && 
		p.y >= bmin.y && p.y <=bmax.y && 
		p.z >= bmin.z && p.z <=bmax.z );
}


int BoxIntersect(const double3 &v0, const double3 &v1, const double3 &bmin, const double3 &bmax,double3 *impact)
{
	if(BoxInside(v0,bmin,bmax))
	{
		*impact=v0;
		return 1;
	}
	if(v0.x<=bmin.x && v1.x>=bmin.x) 
	{
		double a = (bmin.x-v0.x)/(v1.x-v0.x);
		//v.x = bmin.x;
		double vy =  (1-a) *v0.y + a*v1.y;
		double vz =  (1-a) *v0.z + a*v1.z;
		if(vy>=bmin.y && vy<=bmax.y && vz>=bmin.z && vz<=bmax.z) 
		{
			impact->x = bmin.x;
			impact->y = vy;
			impact->z = vz;
			return 1;
		}
	}
	else if(v0.x >= bmax.x  &&  v1.x <= bmax.x) 
	{
		double a = (bmax.x-v0.x)/(v1.x-v0.x);
		//v.x = bmax.x;
		double vy =  (1-a) *v0.y + a*v1.y;
		double vz =  (1-a) *v0.z + a*v1.z;
		if(vy>=bmin.y && vy<=bmax.y && vz>=bmin.z && vz<=bmax.z) 
		{
			impact->x = bmax.x;
			impact->y = vy;
			impact->z = vz;
			return 1;
		}
	}
	if(v0.y<=bmin.y && v1.y>=bmin.y) 
	{
		double a = (bmin.y-v0.y)/(v1.y-v0.y);
		double vx =  (1-a) *v0.x + a*v1.x;
		//v.y = bmin.y;
		double vz =  (1-a) *v0.z + a*v1.z;
		if(vx>=bmin.x && vx<=bmax.x && vz>=bmin.z && vz<=bmax.z) 
		{
			impact->x = vx;
			impact->y = bmin.y;
			impact->z = vz;
			return 1;
		}
	}
	else if(v0.y >= bmax.y  &&  v1.y <= bmax.y) 
	{
		double a = (bmax.y-v0.y)/(v1.y-v0.y);
		double vx =  (1-a) *v0.x + a*v1.x;
		// vy = bmax.y;
		double vz =  (1-a) *v0.z + a*v1.z;
		if(vx>=bmin.x && vx<=bmax.x && vz>=bmin.z && vz<=bmax.z)
		{
			impact->x = vx;
			impact->y = bmax.y;
			impact->z = vz;
			return 1;
		}
	}
	if(v0.z<=bmin.z && v1.z>=bmin.z) 
	{
		double a = (bmin.z-v0.z)/(v1.z-v0.z);
		double vx =  (1-a) *v0.x + a*v1.x;
		double vy =  (1-a) *v0.y + a*v1.y;
		// v.z = bmin.z;
		if(vy>=bmin.y && vy<=bmax.y && vx>=bmin.x && vx<=bmax.x) 
		{
			impact->x = vx;
			impact->y = vy;
			impact->z = bmin.z;
			return 1;
		}
	}
	else if(v0.z >= bmax.z  &&  v1.z <= bmax.z) 
	{
		double a = (bmax.z-v0.z)/(v1.z-v0.z);
		double vx =  (1-a) *v0.x + a*v1.x;
		double vy =  (1-a) *v0.y + a*v1.y;
		// v.z = bmax.z;
		if(vy>=bmin.y && vy<=bmax.y && vx>=bmin.x && vx<=bmax.x) 
		{
			impact->x = vx;
			impact->y = vy;
			impact->z = bmax.z;
			return 1;
		}
	}
	return 0;
}


double DistanceBetweenLines(const double3 &ustart, const double3 &udir, const double3 &vstart, const double3 &vdir, double3 *upoint, double3 *vpoint)
{
	static double3 cp;
	cp = normalize(cross(udir,vdir));

	double distu = -dot(cp,ustart);
	double distv = -dot(cp,vstart);
	double dist = (double)fabs(distu-distv);
	if(upoint) 
	{
		plane plane;
		plane.normal = normalize(cross(vdir,cp));
		plane.dist = -dot(plane.normal,vstart);
		*upoint = PlaneLineIntersection(plane,ustart,ustart+udir);
	}
	if(vpoint) 
	{
		plane plane;
		plane.normal = normalize(cross(udir,cp));
		plane.dist = -dot(plane.normal,ustart);
		*vpoint = PlaneLineIntersection(plane,vstart,vstart+vdir);
	}
	return dist;
}


quaternion VirtualTrackBall(const double3 &cop, const double3 &cor, const double3 &dir1, const double3 &dir2) 
{
	// routine taken from game programming gems.
	// Implement track ball functionality to spin stuf on the screen
	//  cop   center of projection
	//  cor   center of rotation
	//  dir1  old mouse direction 
	//  dir2  new mouse direction
	// pretend there is a sphere around cor.  Then find the points
	// where dir1 and dir2 intersect that sphere.  Find the
	// rotation that takes the first point to the second.
	double m;
	// compute plane 
	double3 nrml = cor - cop;
	double fudgefactor = 1.0/(magnitude(nrml) * 0.25f); // since trackball proportional to distance from cop
	nrml = normalize(nrml);
	double dist = -dot(nrml,cor);
	double3 u= PlaneLineIntersection(plane(nrml,dist),cop,cop+dir1);
	u=u-cor;
	u=u*fudgefactor;
	m= magnitude(u);
	if(m>1)
	{
		u/=m;
	}
	else 
	{
		u=u - (nrml * sqrt(1-m*m));
	}
	double3 v= PlaneLineIntersection(plane(nrml,dist),cop,cop+dir2);
	v=v-cor;
	v=v*fudgefactor;
	m= magnitude(v);
	if(m>1) 
	{
		v/=m;
	}
	else 
	{
		v=v - (nrml * sqrt(1-m*m));
	}
	return RotationArc(u,v);
}

/*
void getSymMatEigenvectorsMelax(double3 * ret, const double3x3 &A)
{
	quaternion q = Diagonalizer(A);
	double3x3 Q = q.getmatrix();
	ret[0].x = Q.x.x; ret[0].y = Q.x.y; ret[0].z = Q.x.z;
	ret[1].x = Q.y.x; ret[1].y = Q.y.y; ret[1].z = Q.y.z;
	ret[2].x = Q.z.x; ret[2].y = Q.z.y; ret[2].z = Q.z.z;
}
*/

// theta is angle from top [0, pi], phi is angle along slice [0, 2pi]
// http://en.wikipedia.org/wiki/Spherical_coordinate_system
void SphericalToCartesean(D3DXVECTOR3 * retVal, float r, float phi, float theta )
{
	retVal->x = r * sin(theta) * cos(phi);
	retVal->y = r * sin(theta) * sin(phi);
	retVal->z = r * cos(theta);
}

void CenterOfMass(D3DXVECTOR3 * retVal, const D3DXVECTOR3 * vertices, const int * tris, const int count)
{
	// count is the number of triangles (tris) 
	D3DXVECTOR3 com = D3DXVECTOR3(0,0,0);
	float volume = 0.0f; // actually accumulates the volume*6

	for(int i=0; i < count; i++)  // for each triangle
	{
		float vol_i = AreaTriangle(&vertices[tris[3*i+0]],&vertices[tris[3*i+1]],&vertices[tris[3*i+2]]);
		D3DXVECTOR3 com_i = (vertices[tris[3*i+0]] + vertices[tris[3*i+1]] + vertices[tris[3*i+2]]);
		com += vol_i * com_i; // Don't divide com_i by 3 --> do it at end for efficiency
		volume+=vol_i;
	}
	com /= (volume*3.0f);
	* retVal = com;
}

float AreaTriangle(const D3DXVECTOR3 * p, const D3DXVECTOR3 * q, const D3DXVECTOR3 * r)
{
	// Temp variables here might slow down function calls... But only done on startup!
	D3DXVECTOR3 temp1((p->x - q->x),(p->y - q->y),(p->z - q->z));
	D3DXVECTOR3 temp2((p->x - r->x),(p->y - r->y),(p->z - r->z));
	D3DXVECTOR3 temp3;
	D3DXVec3Cross(& temp3, & temp1, & temp2);
	return 0.5f * sqrt(temp3.x*temp3.x + temp3.y*temp3.y + temp3.z*temp3.z);
}

// If the input value is already a power of 2 it will just return it.
UINT NextPow2(UINT num)
{
	if(num == 0)
		return 1;
	num--;
	num = (num >> 1) | num;
	num = (num >> 2) | num;
	num = (num >> 4) | num;
	num = (num >> 8) | num;
	// This will convert ...000011001010110 into 000011111111111 (all 1s to the left of the first)
	return num + 1;
}

float Round(float in)
{
	if(in > (floor(in) + 0.5f))
		return ceil(in);
	else
		return floor(in);
}
